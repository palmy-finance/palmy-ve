// SPDX-License-Identifier: MIT
pragma solidity 0.8.10;
import { WadRayMath } from "../libraries/WadRayMath.sol";
import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import { LToken } from "../interfaces/LToken.sol";

/**
 * @title Palmy ERC20 LToken
 * @dev Implementation of the interest bearing token for the Palmy protocol
 * @author HorizonX.tech
 */
contract MockLToken is LToken {
	mapping(address => uint256) private _balances;

	mapping(address => mapping(address => uint256)) private _allowances;

	uint256 private _totalSupply;

	string public name;
	string public symbol;

	uint256 start_time;

	uint256 internal constant RAY = 1e27;
	uint256 internal constant INDEX_GAP = 123 * 1e23;
	uint256 internal constant INDEX = RAY + INDEX_GAP; // ref: ReserveData.liquidityIndex

	constructor(string memory _name, string memory _symbol) {
		name = _name;
		symbol = _symbol;
	}

	using WadRayMath for uint256;

	/**
	 * @dev Mints `amount` lTokens to `user`
	 * - Only callable by the LendingPool, as extra state updates there need to be managed
	 * @param user The address receiving the minted tokens
	 * @param amount The amount of tokens getting minted
	 * @return `true` if the the previous balance of the user was 0
	 */
	function mint(address user, uint256 amount) external returns (bool) {
		uint256 previousBalance = _balances[user];

		uint256 amountScaled = amount.rayDiv(INDEX);

		_mint(user, amountScaled);

		return previousBalance == 0;
	}

	function _mint(address account, uint256 amount) internal virtual {
		require(account != address(0), "ERC20: mint to the zero address");
		_totalSupply += amount;
		_balances[account] += amount;
	}

	function mintToTreasury(address voter, uint256 amount) external {
		if (amount == 0) {
			return;
		}

		_mint(voter, amount.rayDiv(INDEX));
	}

	/**
	 * @dev Calculates the balance of the user: principal balance + interest generated by the principal
	 * @param user The user whose balance is calculated
	 * @return The balance of the user
	 **/
	function balanceOf(address user) public view returns (uint256) {
		return _balances[user].rayMul(INDEX);
	}

	function scaledBalanceOf(address user) external view returns (uint256) {
		return _balances[user];
	}

	/**
	 * @dev Transfers the lTokens between two users. Validates the transfer
	 * (ie checks for valid HF after the transfer) if required
	 * @param from The source address
	 * @param to The destination address
	 * @param amount The amount getting transferred
	 **/
	function _transfer(address from, address to, uint256 amount) internal {
		uint256 index = INDEX;
		uint256 fromBalance = _balances[from];
		require(
			fromBalance >= amount.rayDiv(index),
			"ERC20: transfer amount exceeds balance"
		);
		unchecked {
			_balances[from] -= amount.rayDiv(index);
		}
		_balances[to] += amount.rayDiv(index);
	}

	function approve(
		address spender,
		uint256 amount
	) public virtual returns (bool) {
		address owner = msg.sender;
		_approve(owner, spender, amount);
		return true;
	}

	function _approve(
		address owner,
		address spender,
		uint256 amount
	) internal virtual {
		require(owner != address(0), "ERC20: approve from the zero address");
		require(spender != address(0), "ERC20: approve to the zero address");

		_allowances[owner][spender] = amount;
	}

	function transferFrom(
		address from,
		address to,
		uint256 amount
	) public virtual returns (bool) {
		_transfer(from, to, amount);
		return true;
	}

	function transfer(address to, uint256 amount) public virtual returns (bool) {
		address owner = msg.sender;
		_transfer(owner, to, amount);
		return true;
	}

	function decimals() external pure override returns (uint8) {
		revert("decimals not implemented");
	}

	function totalSupply() external pure override returns (uint256) {
		revert("totalSupply not implemented");
	}

	function scaledTotalSupply() external pure override returns (uint256) {
		revert("scaledTotalSupply not implemented");
	}

	function UNDERLYING_ASSET_ADDRESS() external view override returns (address) {
		return address(this);
	}
}
